---
permalink: /docs/guides/first
layout: doc_subpage
title: Your first project
description: First steps for creating a Web application project using the Typescene framework.
pageintro: Follow along with these steps to create your first Typescene Web application project.
nav: |
    * [Setup](#setup)
    * [Service and model](#service)
    * [Main activity](#activity)
    * [View](#view)
---

__Source code:__ The code for this example project is available on GitHub: [typescene/first-project](https://github.com/typescene/first-project){:target="_blank"}. A JavaScript-only (no TypeScript) version is available as [first-project-js](https://github.com/typescene/first-project-js){:target="_blank"}.

__View online:__ The final output can be seen in action [here](/first-project){:target="_blank"}.

__See also:__ For a more complex example, check out the RealWorld front-end implementation in [this repo](https://github.com/typescene/typescene-realworld-example-app){:target="_blank"}..

### Setup {#setup}

Before getting started with Typescene, make sure you're familiar with JavaScript. Knowledge of TypeScript would also be very useful, especially to understand the reference documentation and autocomplete options, although you could definitely use Typescene with 'plain' modern JavaScript if you don't want to use TypeScript for your own code. To learn Typescript, start with the 5-minute tutorial on the documentation [website](https://www.typescriptlang.org/docs/home.html){:target="_blank"}.

Make sure NodeJS is installed on your computer, and the `npm` command has been added to your `PATH`. To test this, enter `npm -v` in a terminal window, which should show you the current version of NPM.

Source files can be edited using any editor that can save plain text files, but an IDE or editor that is optimized for TypeScript can speed up your workflow a lot. [Microsoft VS Code](https://code.visualstudio.com){:target="_blank"} is an excellent choice.

#### Creating a package

Let's create a folder to hold our project files, and use NPM to initialize our project. This creates a default `project.json` file, which we'll fine-tune later on. We'll also install the Typescene Web app package.

```bash
mkdir first-project
cd first-project
npm init -y
npm install @typescene/webapp
```

#### Copying starter files

The `@typescene/webapp` package includes source files that can be used for getting started with a new project, for both Webpack and Parcel bundlers. We'll need to copy those, as well as the content of the `package.json` file.

> **Note:** These instructions are for a TypeScript project. If you don't want to use TypeScript at all, just copy all the files from the [`first-project-js`](https://github.com/typescene/first-project-js){:target="_blank"} repository.

Run the following command to copy the starter files for use with Webpack, which is what we're going to use here. Don't forget to include the dot at the end.

```bash
npx ncp ./node_modules/@typescene/webapp/setup/minimal-webpack .
```

Take a look at the `SETUP.md` file (copied along with the source files) in your text editor of choice.  This file includes a suggestion for the contents of `package.json`. The following properties are important, so make sure to copy those to the `package.json` file in your own package folder (and remove the default 'scripts' property that was generated by `npm init`):

```json
"scripts": {
  "dev": "webpack-dev-server --hot --config src/webpack.config.js",
  "build": "webpack -p --config src/webpack.config.js"
},
"devDependencies": {
  "typescript": "^3.4.5",
  "webpack": "^4.31.0",
  "webpack-cli": "^3.3.2",
  "webpack-dev-server": "^3.3.1",
  "copy-webpack-plugin": "^5.0.3",
  "ts-loader": "^6.0.0"
}
```

Then return to your terminal and instruct NPM to install all of the new dependencies added to `package.json`:

```bash
npm install
```

#### Testing your setup

To test the 'minimal' app you've just copied to your project folder, start the Webpack development server from your terminal:

```bash
npm run dev
```

Webpack should inform you that its server is now running at [http://localhost:8080/](http://localhost:8080/){:target="_blank"}, and that it has compiled your app along with its own dev-server and hot module replacement code. Opening this address in your browser should show a simple 'Hello, world!' message in the middle of the page.

### 'Todo' Service and model {#service}

Let's build a simple 'todo' app that lets you enter tasks, mark them as done, and remove them. At a high level, we're going to create the following components:

* A service that keeps track of the data model,
* An activity that displays the 'main' screen of the app,
* A view for the main screen.

We'll start with the service. Since the minimal sample code we copied didn't include any services, we'll need to add a folder to our project. It's good practice to keep services together in a separate `services` folder, away from activities and views, since services are often used across multiple activities anyway.

To represent our todo items, we'll extend the [`ManagedRecord`](/docs/ref/ManagedRecord) class. Instances of this class can be kept in a [`ManagedList`](/docs/ref/ManagedList) object which is in turn referenced from the `TodoService` itself, as *managed child* objects. This way, we can simply 'destroy' our todo items to get them removed from the list.

Create the `src/services/TodoService.ts` file in your project (or use `.js` if you don't want to use TypeScript), and add the following code:

```typescript
import { CHANGE, managedChild, ManagedList,
  ManagedRecord, ManagedService } from "typescene";

/** Represents a single to-do item */
export class TodoItem extends ManagedRecord {
  constructor(public text: string) {
    super();
  }
  complete?: boolean;
}

export class TodoService extends ManagedService {
  name = "App.Todo";

  /** Current list of todo items */
  @managedChild
  readonly items = new ManagedList()
    .restrict(TodoItem)
    .propagateEvents();

  nRemaining = 0;
  nCompleted = 0;

  addItem(text: string) {
    if (text) this.items.add(new TodoItem(text));
  }

  removeCompleted() {
    this.items.forEach(it => {
      if (it.complete) this.items.remove(it);
    });
  }
}
TodoService.observe(class {
  constructor(public readonly svc: TodoService) { }

  // called when (any of) the items change(s):
  onItemsChangeAsync() {
    let nCompleted = this.svc.items
      .pluck("complete")
      .filter(b => b).length;
    let total = this.svc.items.count;
    this.svc.nCompleted = nCompleted;
    this.svc.nRemaining = total - nCompleted;
    this.svc.emit(CHANGE);
  }
})

```

Note that we're exposing the `items` property as a public property on the `TodoService` directly. Usually in object-oriented programming we'll only want to expose functionality through getters and setters, *however* since we're restricting the list to instances of `TodoItem` anyway, this is relatively safe and it saves us from having to create methods for all of the list operations, while still being able to watch for changes and guarantee consistency.

Now we need to make sure that we can actually use this service from our activity. We'll *register* an instance of this class in the main file for our app — add the following lines to `src/app.ts`:

```typescript
import { TodoService } from "./services/TodoService";
new TodoService().register();
```

### Main Activity {#activity}

Typescene applications are really just collections of *activities*, which are activated and deactivated as the user navigates around the app. Activities represent the overall application state, and contain most of the logic that runs in response to user actions. In the case of our 'todo' app, we'll only need one activity.

The code for a `MainActivity` class is already included in the minimal code we copied from the Web app package, but that doesn't do much at all.

Find the `src/activities/main/activity.ts` file, and remove the code for the `onManagedStateActiveAsync` method, since we don't need this handler for now. Add the following lines instead:

```typescript
@service("App.Todo")
todo?: TodoService;
```

> __Note:__ The code above requires the symbols `service` and `TodoService` to be imported at the top of the file. If you're using Visual Studio Code, a lightbulb shows up when you select these IDs — click the icon and you'll find an option to add imports automatically. Alternatively, read on for a full listing of the finished activity source file.

This seems like a lot of code to refer to the `TodoService` we created earlier, but every part has its own purpose here:

1. The [`@service`](/docs/ref/service) decorator turns the ordinary `todo` property into a *service property*, which keeps the property value up to date as services are registered, destroyed, or replaced.
2. `"App.Todo"` is the exact name of the service that we're looking for, provided to the decorator as a string parameter.
3. `todo` is the property name that we're adding to the activity class.
4. `?: TodoService` is a TypeScript type annotation that tells the compiler that our `todo` property refers to an instance of our `TodoService` class *or* may be set to undefined (since we're not actually setting the property directly; however in practice the service is already registered when the activity is created, so the property has a value all the time).

To accept entry of new tasks using a text field without having to listen for changes to the text field itself, we'll use a *form context controller* in our UI. The controller binds to a managed object on the activity, and provides a reference to this 'form context' to all child components. Let's create the form context and store it in a `formInput` property:

```typescript
@managedChild
formInput = ManagedRecord.create({
  newTask: ""
});
```

Furthermore, the activity needs to be able to handle events that come in from the view. Let’s add some handler methods for adding a task, removing all completed tasks, and toggling the state of a task (which listens for a [`UIListCellAdapterEvent`](/docs/ref/UIListCellAdapterEvent), a special type of event that’s emitted by a list item cell and includes a reference to the list item’s *object* — the managed object that’s represented by the cell that generated the original event).

Here's the final version of our `src/activities/main/activity.ts` file:

```typescript
import { CHANGE, managedChild, ManagedRecord,
  PageViewActivity, service,
  UIListCellAdapterEvent } from "typescene";
import { TodoItem, TodoService } from "../../services/TodoService";
import view from "./view";

export class MainActivity
  extends PageViewActivity.with(view) {
  path = "/";

  @service("App.Todo")
  todo?: TodoService;

  /** Form context for the 'add a task' text field */
  @managedChild
  formInput = ManagedRecord.create({
    newTask: ""
  });

  // event handlers:

  addTask() {
    this.todo!.addItem(this.formInput.newTask);
    this.formInput.newTask = "";
    this.formInput.emit(CHANGE);
  }

  toggleTask(e: UIListCellAdapterEvent<TodoItem>) {
    if (e.object instanceof TodoItem) {
      e.object.complete = !e.object.complete;
      e.object.emit(CHANGE);
    }
  }

  removeCompleted() {
    this.todo!.removeCompleted();
  }
}
```

### View {#view}

Now that we have a service to store our data, and an activity to make it available, we can create a view to display it.

We'll divide the view into three regions:
1. A heading with the title of the app,
2. a form to enter new task names,
3. the current list of items,
4. a footer that shows a status bar when the list is not empty.

Since we'll want the entire page to scroll up and down, we start with a [`UIScrollContainer`](/docs/ref/UIScrollContainer) component. Within, we'll want to restrict the width of the page and add some padding while keeping all content at the top of the page, which can be achieved using the [`UIFlowCell`](/docs/ref/UIFlowCell) component.

Here's a start for the page header within the two wrapper components:

```typescript
UIScrollContainer.with(
  UIFlowCell.with(
    {
      dimensions: { width: 640, maxWidth: "100vw" },
      position: { gravity: "center" },
      padding: { top: 32, x: 16 }
    },

    // page header:
    UIRow.with(
      UILabel.withIcon("check", 40, "@green"),
      UIHeading1.withText("Todo"),
    )
  )
)
```

For the task input form, well use a [`UIFormContextController`](/docs/ref/UIFormContextController) component. This introduces a 'form context' object to its child components, which can be used for two-way synchronization of input values (as opposed to bindings, which only perform one-way updates). We'll bind the form context to the `formInput` record we've created above.

The form itself consists of a text field and a button.
* The text field has a `name` property that's set to the form context _property name_, which we'll use to read and write the input value.
* The text field and button share a common event handler `addTask()` that refers to the `addTask` method that's part of the Activity component.

Add the following code to the `UIFlowCell` wrapper:

```typescript
// ... add this to the UIFlowCell above:
UIFlowCell.with(
  {
    padding: { x: 16, y: 8 },
    borderColor: "@separator",
    borderThickness: 1
  },
  UIFormContextController.with(
    { formContext: bind("formInput") },
    UIRow.with(
      UIBorderlessTextField.with({
        name: "newTask",
        placeholder: "Enter a task...",
        onEnterKeyPress: "addTask()"
      }),
      UIBorderlessButton.withLabel(
        "Add", "addTask()")
    )
  )
)
```

For the list of current tasks, we'll use the [`UIListController`](/docs/ref/UIListController) component and bind its `items` property to a managed list. In this case we can bind directly to the `items` list of the `TodoService`. The service is referenced by the Activity using its `todo` property, so we'll pass `bind("todo.items")` to the list controller constructor.

The list controller encapsulates a component constructor (second argument to `with` below) that works as a 'template' for all items in the list. When the list emits its change events, the list controller updates the list automatically by adding, removing, and reordering instances of this constructor.

The template constructor should accept a single argument — the list item object itself — and render a [`UIContainer`](/docs/ref/UIContainer) component. This makes the component an 'adapter' for the item. We don't need to create an adapter from scratch, instead we can use the [`UIListCellAdapter`](/docs/ref/UIListCellAdapter) class, which exposes an `object` property that we can bind to from within the cell component.

```typescript
UIListController.with(
  {
    items: bind("todo.items"),
    onToggleTask: "toggleTask()"
  },

  // list item template:
  UIListCellAdapter.with(
    { padding: { x: 16, y: 8 } },
    UIRow.with(
      UIToggle.with({
        state: bind("object.complete"),
        onChange: "+ToggleTask"
      }),
      UIExpandedLabel.with({
        text: bind("object.text"),
        onClick: "+ToggleTask"
      })
    )
  ),

  // list container:
  UIFlowCell.with({
    separator: { type: "line" }
  })
)
```

Note how we're emitting a custom `ToggleTask` event from within the `UIListCellAdapter`. The adapter propagates this event, while also adding an `object` property that refers to the list item (we use this as `e.object` in the Activity code above) — however we'll need to handle the event _outside_ the adapter itself because if we handle it before propagation, the event doesn't contain this special property yet.

Finally, we'll add a footer. We can hide the footer cell when it's not needed by binding its `hidden` property to the `count` property of our managed list — except we need to _show_ the list when count is nonzero, so the binding to use for `hidden` is `bind("!todo.items.count")`.

The footer mostly has a label with the number of uncompleted tasks remaining, which we'll create using `UILabel.with`, but we'll also set the text color to `{@text/50%}` (see [colors](/docs/guides/ui#colors)), and incorporate a nested binding using `${todo.nRemaining}` (see [`bindf`](/docs/ref/bindf)). We can even use I18n pluralization using `#{/s}`, all using a single string.

```typescript
UIFlowCell.with(
  { hidden: bind("!todo.items.count") },
  UISeparator,
  UISpacer,
  UICenterRow.with(
    UILabel.with({
      text: bindf("${todo.nRemaining} task#{/s} remaining"),
      textStyle: { color: "@text/50%" }
    }),
    UILinkButton.with({
      hidden: bind("!todo.nCompleted"),
      label: "Remove completed",
      onClick: "removeCompleted()"
    })
  )
)
```

Here's the final version of our `src/activities/main/view/index.ts` file, with some transitions and other features added in:

```typescript
import { HMR } from "@typescene/webapp";
import { bind, tl, UIBorderlessButton, UIBorderlessTextField,
  UICenterRow, UIExpandedLabel, UIFlowCell,
  UIFormContextController, UIHeading1, UILabel,
  UILinkButton, UIListCellAdapter, UIListController,
  UIRow, UIScrollContainer, UISeparator, UISpacer, UIStyle,
  UIStyleController, UIToggle } from "typescene";

export default HMR.enableViewReload(
  module,
  UIScrollContainer.with(
    UIFlowCell.with(
      {
        dimensions: { width: 640, maxWidth: "100vw" },
        position: { gravity: "center" },
        padding: { top: 32, x: 16 },
        revealTransition: "fade"
      },

      // --------------------------------------
      // page heading:
      UIRow.with(
        UILabel.withIcon("check", 40, "@green"),
        UIHeading1.withText("Todo"),
      ),
      UISpacer.withHeight(32),

      // --------------------------------------
      // new task input form:
      UIFlowCell.with(
        {
          padding: { x: 16, y: 8 },
          borderColor: "@separator",
          borderThickness: 1
        },
        UIFormContextController.with(
          { formContext: bind("formInput") },
          UIRow.with(
            UIBorderlessTextField.with({
              name: "newTask",
              placeholder: "Enter a task...",
              requestFocus: true,
              onEnterKeyPress: "addTask()"
            }),
            UIBorderlessButton.withLabel(
              "Add", "addTask()")
          )
        )
      ),
      UISpacer.withHeight(16),

      // --------------------------------------
      // items list:
      UIListController.with(
        {
          items: bind("todo.items"),
          onToggleTask: "toggleTask()"
        },

        // list item template:
        UIListCellAdapter.with(
          { padding: { x: 16, y: 8 } },
          UIRow.with(
            { revealTransition: "down-fast" },
            UIToggle.with({
              state: bind("object.complete"),
              onChange: "+ToggleTask"
            }),
            UIStyleController.with(
              {
                state: bind("object.complete"),
                styles: {
                  true: UIStyle.create({
                    textStyle: { strikeThrough: true }
                  })
                }
              },
              UIExpandedLabel.with({
                text: bind("object.text"),
                onClick: "+ToggleTask"
              })
            )
          )
        ),

        // list container:
        UIFlowCell.with({
          separator: { type: "line" },
          animatedContentRenderingDuration: 200
        })
      ),

      // --------------------------------------
      // footer, if non-empty
      UIFlowCell.with(
        { hidden: bind("!todo.items.count") },
        UISeparator,
        UISpacer,
        UICenterRow.with(
          UILabel.with({
            text: bindf("${todo.nRemaining} task#{/s} remaining"),
            textStyle: { color: "@text/50%" }
          }),
          UILinkButton.with({
            hidden: bind("!todo.nCompleted"),
            label: "Remove completed",
            onClick: "removeCompleted()"
          })
        )
      )
    )
  )
)
```

That's all — we've created a service, an activity, and a view. Run the `npm run dev` command on the command line and point a browser to [http://localhost:8080/](http://localhost:8080/){:target="_blank"} to see your app in action. Thanks to the `HMR` code above (for 'Hot Module Reload', a feature of both Webpack and Parcel) you can make changes to the view's source code, save the file, and instantly see your changes in the browser. Note that this doesn't work for the activity or service, since those would affect the state of the running application.

View or clone the above source code on GitHub at [typescene/first-project](https://github.com/typescene/first-project){:target="_blank"}, and see it online [here](/first-project){:target="_blank"}.
