<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="Description" content="Detailed description of the Component class">
    <meta name="viewport" content="width=device-width, maximum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Typescene - Components</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-96048899-3"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-96048899-3');
    </script>
    <!-- end GA -->
    <link rel="stylesheet" href="/assets/style.css">
    <link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono:400,300i|IBM+Plex+Sans:200,300,500,800,200i,300i,500i" rel="stylesheet">
    <link rel="canonical" href="https://typescene.dev/docs/concepts/components">
</head>
<body>
    <nav class="topnav">
        <section class="wrapper">
            <a href="/" class="logo_link">
                <img src="/assets/logo_small.png" alt="Typescene logo" class="topnav_logo">
                <span class="topnav_title">Typescene</span>
            </a>
            <ul class="topnav_links">
                <li><a href="#" onclick="return showDocWidget()"><img src="/assets/icons/search-reverse.svg" alt="" width=16 style="position: relative; top: .125rem">&nbsp; Docs</a></li>
                <li class="hide_small"><a href="https://github.com/typescene/typescene" target="_blank" rel="noopener">Github</a></li>
            </ul>
        </section>
    </nav>

    
<link rel="preload" href="/assets/icons/chevron.svg" as="image" />
<div id="breadcrumb_bar">
  <section class="wrapper">
      <a href="/" class="logo_link" id="breadcrumb_logo" hidden>
          <img src="/assets/logo_small.png" alt="Typescene logo" class="topnav_logo">
      </a>
      <span>
          <a href="/docs">Documentation</a>
          &nbsp;|&nbsp Concepts
      </span>
  </section>
</div>
<article class="wrapper wrapper--page">
    <div class="wrapper_columns">
        <div class="wrapper_column">
            <div class="pagetitle_container">
                <h1>Components</h1>
                <p class="style--pageintro">The Component class provides much of the infrastructure that is used by other Typescene classes. This page explains all of its features in detail.
</p>
            </div>

            <h2>The <code>Component</code> class</h2>


<p>The base class for all components in Typescene is the <a href="/docs/ref/Component"><code>Component</code></a> class. To create your own component, simply extend this class.</p>
<p><a href="/docs/ref/Component" class="block_link class"><strong>Component</strong><br>Component base class</a></p>
<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> MyComponent();
</code></pre>
<p>This class won’t do anything useful on its own, though. The <code>Component</code> class only provides a common infrastructure layer; other classes build on top of this layer to define specific functionality for views, activities, and services. The base class provides a number of features:</p>
<ul>
<li>Reference management</li>
<li>Emitting and handling events</li>
<li>Observing property changes</li>
<li>Life cycle states (created, active/inactive, destroyed)</li>
<li>Declaration of preset constructors (factories)</li>
</ul>
<p>Let’s look at each of these features in detail.</p>
<blockquote>
<p><strong>Note:</strong> The <code>Component</code> class extends another class, the <a href="/docs/ref/ManagedObject"><code>ManagedObject</code></a> class. This class is also extended by the <code>ManagedList</code> and <code>ManagedMap</code> classes (see <a href="/docs/concepts/lists-maps">Lists and maps</a>). Some of the features described here are actually part of the <code>ManagedObject</code> implementation, although application code should never need to extend the <code>ManagedObject</code> class directly — use the <code>Component</code> class whenever possible.</p>
</blockquote>
<h2 id="references">Component references</h2>


<p>References between components can be marked as ‘managed’:</p>
<p><a href="/docs/ref/managed" class="block_link decorator"><strong>@managed</strong><br>Property decorator: turn a property into a managed reference to another component</a></p>
<blockquote>
<p><strong>Note:</strong> Property decorators are available in TypesScript and in some variations of transpiled JavaScript. For more information and for ways to implement decorators in plain JavaScript, refer to the <a href="/docs/js-ts/">differences between JavaScript and TypeScript</a>.</p>
</blockquote>
<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOtherComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-meta">@managed</span>
  other = <span class="hljs-keyword">new</span> MyOtherComponent();
}
</code></pre>
<p>The <a href="/docs/ref/managed"><code>@managed</code></a> decorator can be used on a property that’s intended to reference another component. This enables the following behavior:</p>
<ul>
<li>Type validation: managed properties <em>must</em> reference a Component instance, nothing else (but they can be <code>undefined</code>).</li>
<li>Life cycle state validation: managed properties cannot refer to a component that&#39;s in a &#39;destroyed&#39; state (see <a href="#ids-state">IDs and state</a> below -- components in this state are basically invalid, and most of the Component features described here are disabled after the component is destroyed, even if your code can still &#39;see&#39; the object).</li>
<li>Dereferencing: when a component is destroyed, managed properties that referenced this component are automatically set to <code>undefined</code>.</li>
</ul>
<pre><code class="language-typescript"><span class="hljs-comment">// property values are checked</span>
<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> MyComponent();
c.other = <span class="hljs-keyword">new</span> MyOtherComponent()  <span class="hljs-comment">// fine</span>
c.other = <span class="hljs-number">123</span>  <span class="hljs-comment">// ERROR</span>
c.other = someDestroyedComponent  <span class="hljs-comment">// ERROR</span>
</code></pre>
<h3>Parent-child references</h3>


<p>Additionally, references can be marked as ‘parent-child’ dependencies, using the <a href="/docs/ref/managedChild"><code>@managedChild</code></a> property decorator.</p>
<p><a href="/docs/ref/managed" class="block_link decorator"><strong>@managedChild</strong><br>Property decorator: turn a property into a managed parent-child reference</a></p>
<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// ...</span>
  
  <span class="hljs-meta">@managedChild</span>
  child = <span class="hljs-keyword">new</span> MyOtherComponent();
}
</code></pre>
<p>In object-oriented terms, this enforces a ‘has-a’ relationship: the parent takes ownership of the child component. Therefore, the lifecycle of a child component depends on its parent (which may be somewhat unintuitive considering the literal meaning of these terms, but this is a common data structure concept).</p>
<p>When the parent component is destroyed, <em>or</em> when the same property of the parent component no longer references the child component, the child component is destroyed immediately.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> MyComponent();
<span class="hljs-keyword">let</span> child = c.child;
c.child = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// no longer referenced</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(
    child.managedState === ManagedState.DESTROYED
  ); <span class="hljs-comment">// =&gt; true</span>
}, <span class="hljs-number">1</span>);
</code></pre>
<h3>Tree structures </h3>


<p>To represent a tree structure, you can use Typescene’s <a href="/docs/concepts/lists-maps">List and Map</a> classes together with the <code>@managedChild</code> decorator. Lists and maps will automatically extend parent-child relationships to the objects they contain. Specifically, when a <code>@managedChild</code> property refers to a list or map, each of the objects within the list/map becomes a child component:</p>
<ul>
<li>When the parent object is destroyed, the list/map is destroyed along with the objects it contains.</li>
<li>When the parent object no longer references the list/map, it is destroyed along with the objects it contains.</li>
<li>When an object is removed from the list/map, it is destroyed immediately. </li>
</ul>
<p>For example, view components contained by <code>UIRow</code> and <code>UIColumn</code> components are <em>child</em> components, even if they are referenced indirectly through a <code>ManagedList</code> in the <code>content</code> property.</p>
<p>The following example shows how child components in a list are destroyed when they are no longer part of the list.</p>
<pre><code class="language-typescript"><span class="hljs-comment">// child gets destroyed when removed from a list:</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-meta">@managedChild</span>
  list = <span class="hljs-keyword">new</span> ManagedList(
    <span class="hljs-keyword">new</span> MyComponent(),
    <span class="hljs-keyword">new</span> MyComponent()
  );
}

<span class="hljs-keyword">let</span> listComponent = <span class="hljs-keyword">new</span> MyListComponent();
<span class="hljs-keyword">let</span> firstChild = listComponent.list.first()!;
listComponent.list.clear(); <span class="hljs-comment">// items are destroyed</span>

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(
    firstChild.managedState === ManagedState.DESTROYED
  ); <span class="hljs-comment">// =&gt; true</span>
}, <span class="hljs-number">1</span>)
</code></pre>
<p><a href="/docs/concepts/lists-maps" class="block_link doc"><strong>See also:</strong> Concepts &gt; Lists and maps</a></p>
<h2 id="events">Events</h2>


<p>Components can <em>emit events</em>, for a variety of reasons — for example when the user interacts with a UI component, or when the state of a data model or service changes. These events can then be handled by components that <em>include a reference</em> to the emitting component (using managed references, as described above).</p>
<p>You can emit your own events: any instance of the <code>ManagedEvent</code> class can be emitted using the <a href="/docs/ref/ManagedObject#ManagedObject:emit"><code>emit()</code></a> method of a component. For components that hold some type of data, the <a href="/docs/ref/ManagedObject#ManagedObject:emitChange"><code>emitChange()</code></a> method provides an efficient way to emit a &#39;Change&#39; event — signaling that the data has changed — without having to construct the event object itself.</p>
<p><a href="/docs/ref/ManagedObject#ManagedObject:emit" class="block_link method"><strong>ManagedObject.emit()</strong><br>Emit an event</a>
<a href="/docs/ref/ManagedObject#ManagedObject:emitChange" class="block_link method"><strong>ManagedObject.emitChange()</strong><br>Emit a change event (instance of <code>ManagedChangeEvent</code>)</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> MyComponent()
c.emit(<span class="hljs-keyword">new</span> ManagedEvent(<span class="hljs-string">&quot;Hello&quot;</span>));
c.emit(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// same thing</span>
c.emitChange();
</code></pre>
<h3>Handling events</h3>


<p>Events can be handled in one of the following ways:</p>
<ul>
<li>By &#39;propagating&#39; events from child components, or</li>
<li>Using a component observer (see <a href="#observers">Observers</a> below).</li>
</ul>
<p>Event propagation is particularly useful for components that are part of a tree structure. When a child component emits an event (e.g. a <code>Click</code> event on a UI button component, or a <code>Change</code> event on an address data record), it’s often desirable to emit an event on the containing component as well (e.g. the row container that contains the button, or the contact record that refers to the address).</p>
<p>To do this, use the <a href="/docs/ref/ManagedObject#ManagedObject:propagateChildEvents"><code>propagateChildEvents</code></a> method. This method accepts a callback function as its only argument, which is called whenever an event has been emitted by any child component. The function may return either the same event, or another one (or nothing at all) to emit an event on the parent component itself.</p>
<p><a href="/docs/ref/ManagedObject#ManagedObject:propagateChildEvents" class="block_link method"><strong>ManagedObject.propagateChildEvents()</strong><br>Propagate events from managed child objects</a></p>
<pre><code class="language-typescript"><span class="hljs-comment">// usually used in the component constructor:</span>
c.propagateChildEvents(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (e.name === <span class="hljs-string">&quot;Hello&quot;</span>) <span class="hljs-keyword">return</span> e;
  <span class="hljs-comment">// ... otherwise, return nothing</span>
});

c.child.emit(<span class="hljs-string">&quot;Hello&quot;</span>)  <span class="hljs-comment">// propagated on c</span>
c.child.emitChange()  <span class="hljs-comment">// not propagated on c</span>
</code></pre>
<p>You can use the <code>propagateChildEvents</code> callback to take any action before the event is propagated, if at all. This makes it the simplest way to handle events, as long as the event source is referenced through a managed child reference property.</p>
<blockquote>
<p><strong>Note:</strong> The built-in events <a href="/docs/ref/ManagedCoreEvent#ManagedCoreEvent:ACTIVE">&#39;Active&#39;</a>, <a href="/docs/ref/ManagedCoreEvent#ManagedCoreEvent:INACTIVE">&#39;Inactive&#39;</a>, and <a href="/docs/ref/ManagedCoreEvent#ManagedCoreEvent:DESTROYED">&#39;Destroyed&#39;</a> are emitted automatically when the state of a component changes to active, inactive, and destroyed states, respectively (see &#39;IDs and state&#39; below). However, these events <em>cannot</em> be propagated.</p>
</blockquote>
<h2 id="observers">Observers</h2>


<p>A more advanced method for handling events is to add a component <em>observer</em>. Observers can handle events emitted by the component itself, as well as those emitted by referenced components. In addition, observers can be used to observe <em>property changes</em> of the component object.</p>
<p>Observers are used extensively by the Typescene framework itself, for example to watch for changes to UI component properties (e.g. the <code>text</code> property of a <code>UILabel</code> component), and update elements on screen accordingly.</p>
<p>Use the static <a href="/docs/ref/ManagedObject#ManagedObject:addObserver"><code>addObserver</code></a> method of a component class to add an observer of your own:</p>
<p><a href="/docs/ref/ManagedObject#ManagedObject:addObserver" class="block_link method"><strong>ManagedObject.addObserver()</strong><br>Add an observer to all instances of this class and derived classes</a></p>
<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservedComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-meta">@managed</span> other = <span class="hljs-keyword">new</span> MyOtherComponent();
  foo = <span class="hljs-number">123</span>;
}

<span class="hljs-comment">// add an observer class:</span>
ObservedComponent.addObserver(<span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
    <span class="hljs-title">constructor</span> (<span class="hljs-params"><span class="hljs-keyword">public</span> observed: ObservedComponent</span>) {
      <span class="hljs-comment">// called with each new ObservedComponent instance</span>
    }

<span class="hljs-comment">// ... (continue below)</span>
</code></pre>
<p>An observer <em>instance</em> is created for each new instance of the observed component, providing a reference to the observer’s constructor.</p>
<p>Methods of the observer class are then invoked whenever a property changes or an event occurs. Typescene invokes the appropriate method based on the method name:</p>
<ul>
<li><code>onFooChange</code> is called whenever a property <code>foo</code> changes, <em>or</em> when a ‘Change’ event is emitted on a component that is referenced by the (managed) <code>foo</code> property.</li>
<li><code>onEventName</code> is called when an event with name <code>EventName</code> is emitted by the component itself.</li>
<li><code>...Async</code> methods are called when a change or event occurs, but only after the code surrounding the statement that makes the change has completed. Async methods are always invoked only once, even if multiple changes or events occurred.</li>
</ul>
<pre><code class="language-typescript"><span class="hljs-comment">// ... define methods:</span>
    <span class="hljs-function"><span class="hljs-title">onOtherChange</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-comment">// called when (1) the observed.other property changes</span>
      <span class="hljs-comment">// or (2) a change event is emitted on observed.other</span>
      <span class="hljs-built_in">this</span>.observed.doSomething()
    }
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">onOtherChangeAsync</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-comment">// same as above, but asynchronously</span>
    }
    <span class="hljs-function"><span class="hljs-title">onFooChange</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">/* when observed.foo changes */</span> }
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">onFooChangeAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">/* same, but async */</span> }
    <span class="hljs-function"><span class="hljs-title">onHello</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-comment">// called when an event with name Hello is emitted</span>
      <span class="hljs-comment">// on the observed component itself</span>
    }
});
</code></pre>
<p>In addition, observer methods can be decorated using the following decorators to specify when an observer method should be called.</p>
<p><a href="/docs/ref/onPropertyEvent" class="block_link decorator"><strong>@onPropertyEvent</strong><br>Observer method decorator: call a method when an event is emitted by a referenced object</a>
<a href="/docs/ref/onPropertyChange" class="block_link decorator"><strong>@onPropertyChange</strong><br>Observer method decorator: call a method when a property value changes</a>
<a href="/docs/ref/rateLimit" class="block_link decorator"><strong>@rateLimit</strong><br>Observer method decorator: call a method at most once within a specific time frame</a></p>
<h2 id="ids-state">IDs and state</h2>


<p>To keep track of component references internally, Typescene uses a unique ID that&#39;s assigned to every component instance as soon as it is created. This number is available through the read-only <code>managedId</code> field.</p>
<p><a href="/docs/ref/ManagedObject#ManagedObject:managedId" class="block_link property"><strong>ManagedObject.managedId</strong><br>Unique object identifier</a></p>
<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{ }
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> MyComponent().managedId)  <span class="hljs-comment">// e.g. 16</span>
</code></pre>
<p>The <a href="/docs/ref/ManagedObject#ManagedObject:managedState"><code>managedState</code></a> field is another read-only component field. This represents the current &#39;state&#39; of the component, i.e. one of the values defined on the <a href="/docs/ref/ManagedState"><code>ManagedState</code></a> enumeration object.</p>
<p><a href="/docs/ref/ManagedObject#ManagedObject:managedState" class="block_link property"><strong>ManagedObject.managedState</strong><br>The current lifecycle state</a></p>
<p><a href="/docs/ref/ManagedObject#ManagedObject:managedId" class="block_link type"><strong>ManagedState</strong><br>Enumeration of possible states for a managed object</a></p>
<ul>
<li><code>ManagedState.CREATED</code> -- the initial state</li>
<li><code>ManagedState.DESTROYED</code> -- a state in which the component should not be used anymore, can no longer be referenced from other components, and cannot emit events; this state is permanent</li>
<li><code>ManagedState.ACTIVE</code> -- mostly used for activities and applications, to signify that corresponding view(s) should be rendered to the screen</li>
<li><code>ManagedState.INACTIVE</code> -- the component is no longer active</li>
<li><code>*.ACTIVATING</code>, <code>*.INACTIVATING</code>, <code>*.DESTROYING</code> -- the component is transitioning from one state to another.</li>
</ul>
<p>You don&#39;t usually need to change a component&#39;s state yourself, but you may want to handle state changes when they occur — e.g. to trigger loading some data for an Activity as it becomes &#39;active&#39;.</p>
<p>State transitions are <em>asynchronous</em>, and can only be initiated using the following (protected) methods:</p>
<ul>
<li><code>activateManagedAsync()</code> — to transition to the active state;<ul>
<li>While activating, the component calls its own <code>onManagedStateActivatingAsync()</code> method, which can be overridden to intercept the state transition. Throwing an error cancels the transition.</li>
<li>After the component becomes &#39;active&#39;, the <code>onManagedStateActiveAsync()</code> method is called.</li>
</ul>
</li>
<li><code>deactivateManagedAsync()</code> — to transition (back) to the inactive state;<ul>
<li>While deactivating, the component calls its own <code>onManagedStateDeactivatingAsync()</code> method, which can be overridden. Throwing an error cancels the transition.</li>
<li>After the component becomes &#39;inactive&#39;, the <code>onManagedStateInactiveAsync()</code> method is called.</li>
</ul>
</li>
<li><code>destroyManagedAsync()</code> — to transition to the destroyed state;<ul>
<li>If the component was in ‘active’ state, it is always deactivated first.</li>
<li>While destroying, the component calls its own <code>onManagedStateDestroyingAsync()</code> method, which can be overridden. Throwing an error does <em>not</em> cancel the transition.</li>
</ul>
</li>
</ul>
<p>Be careful to avoid typos when overriding these methods — their names are long to make sure they don’t interfere with your own methods.</p>
<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PageViewActivity</span>.<span class="hljs-title">with</span>(<span class="hljs-title">view</span>) </span>{
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">onManagedStateActivatingAsync</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-built_in">super</span>.onManagedStateActivatingAsync();
    <span class="hljs-comment">// ...e.g. load some data here...</span>
  }
}
</code></pre>
<hr>
<h3>Recap</h3>


<p>So far, we&#39;ve seen that components</p>
<ul>
<li>can reference each other through &#39;managed&#39; properties, with Typescene automatically managing some relationships</li>
<li>can emit events, which may be handled and &#39;propagated&#39; through parent-child references</li>
<li>can be observed (for properties changes and events)</li>
<li>have an ID and an asynchronously managed state.</li>
</ul>
<p>There is one more feature that changes the way components are used in a Typescene app, and makes a large difference to code readability: declarative constructors.</p>
<h2 id="preset">Declarations</h2>


<p>With the features described above, it would be possible to create a functioning Typescene application. For example, you could create a row of buttons just like this:</p>
<pre><code class="language-typescript"><span class="hljs-comment">// this works, but...</span>
<span class="hljs-keyword">let</span> row = <span class="hljs-keyword">new</span> UIRow();
row.height = <span class="hljs-number">48</span>;
<span class="hljs-keyword">let</span> button2 = <span class="hljs-keyword">new</span> UIPrimaryButton();
button2.label = <span class="hljs-string">&quot;OK&quot;</span>;
<span class="hljs-keyword">let</span> button1 = <span class="hljs-keyword">new</span> UIButton();
button1.label = <span class="hljs-string">&quot;Cancel&quot;</span>;
row.content.add(button1, button2);
row.propagateChildEvents(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> { <span class="hljs-comment">/* etc... */</span> })
</code></pre>
<p>However, that’s not efficient at all, and especially with more components it’s easy to make mistakes. If event handlers modify components, or add or remove them, it’s difficult to understand what the final result looks like.</p>
<p>As an alternative, Typescene lets you <em>declare</em> components, before creating any instances using <code>new</code>. A <em>declaration</em> for the row in the example above becomes much simpler:</p>
<pre><code class="language-typescript"><span class="hljs-comment">// same, but different:</span>
<span class="hljs-keyword">const</span> preset = UIRow.with(
  { <span class="hljs-attr">height</span>: <span class="hljs-number">48</span> },
  UIPrimaryButton.withLabel(<span class="hljs-string">&quot;OK&quot;</span>),
  UIButton.withLabel(<span class="hljs-string">&quot;Cancel&quot;</span>)
)

<span class="hljs-keyword">let</span> row = <span class="hljs-keyword">new</span> preset();
</code></pre>
<p>Every component has a static <code>with(...)</code> method, and some components have related methods such as <code>withLabel</code>. Note that these methods do <strong>not</strong> return a component, but a <em>constructor</em>. This ‘preset’ constructor can be used to create components with content and properties exactly as specified in the declaration.</p>
<p><a href="/docs/ref/Component#Component:with" class="block_link method"><strong>Component.with()</strong><br>Create a preset constructor (i.e. a class that is the result of a component declaration)</a></p>
<h3>Property values</h3>


<p>If the first argument to <code>with</code> is a plain object (i.e. <code>{ ... }</code>), then by default, all properties from that object are copied to instances created using the preset constructor.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">let</span> MyButton = UIButton.with({ <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Cancel&quot;</span> });

<span class="hljs-keyword">let</span> btn1 = <span class="hljs-keyword">new</span> MyButton();
<span class="hljs-built_in">console</span>.log(btn1.label);  <span class="hljs-comment">// =&gt; &quot;Cancel&quot;</span>
<span class="hljs-keyword">let</span> btn2 = <span class="hljs-keyword">new</span> MyButton();
<span class="hljs-built_in">console</span>.log(btn2.label);  <span class="hljs-comment">// =&gt; &quot;Cancel&quot;</span>
</code></pre>
<p>However, some properties aren&#39;t just copied. Components can define their own preset logic, but there are two exceptions that are shared by all components: <em>bindings</em> and <em>event handlers</em>.</p>
<h3>Bindings</h3>


<p>If you add a ‘binding’ to a preset object — i.e. the result of a call to <a href="/docs/ref/bind"><code>bind</code></a> or <a href="/docs/ref/bindf"><code>bindf</code></a>, then the corresponding property on the preset component becomes &#39;bound&#39; to a property of one of its parent components, allowing it to be updated dynamically.</p>
<p><a href="/docs/ref/bind" class="block_link function"><strong>bind()</strong><br>Create a new binding for a given property name</a>
<a href="/docs/ref/bindf" class="block_link function"><strong>bindf()</strong><br>Create a new binding using a format string</a>
<a href="/docs/ref/Binding" class="block_link class"><strong>Binding</strong><br>Represents a binding, created using <code>bind</code> or <code>bindf</code></a></p>
<p>Here’s an example of a preset view component that includes a binding:</p>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> view = UICell.with(
  UICenterRow.with(
    UILabel.with({
      <span class="hljs-attr">text</span>: bind(<span class="hljs-string">&quot;labelText&quot;</span>),
      <span class="hljs-attr">textStyle</span>: { <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span> }
    })
  )
)
</code></pre>
<p>This enables the following behavior:</p>
<ol>
<li>When this component is created on its own, the <code>text</code> property of the label is undefined — the binding isn’t bound yet at all.</li>
<li>When an activity sets its <code>view</code> property to the newly created view component, it makes the view component a <em>child</em> component of the activity.</li>
<li>Typescene notices that the view’s parent component has changed, and informs the binding that it can now be bound to the activity object.</li>
<li>The binding takes the value from the <code>labelText</code> property of the activity, and assigns it to the label’s <code>text</code> property.</li>
<li>The <code>labelText</code> property is observed, so that every time its value changes, the label’s <code>text</code> property is updated accordingly.</li>
</ol>
<p>Bindings allow for updates to deeply nested components (e.g. setting the <code>text</code> property of a label, which is in a row, which is in a cell, etc.) without the need for a direct reference to the component. This is key to how views (and in some cases, activities) are used in Typescene applications.</p>
<blockquote>
<p><strong>Note:</strong> How do bindings find their bound parent components? While it’s intuitively understandable that a view takes its bound values from a parent activity, there’s nothing special about views and activities that makes this work. Views can be bound to other view components as well. Remember, these features exist on the generic <code>Component</code> class. Refer to <a href="#custom">Custom presets</a> below to learn more about how this works.</p>
</blockquote>
<p>Bindings don’t always need to refer to a single property value:</p>
<ul>
<li>Nested properties can be bound using e.g. <code>bind(&quot;user.name&quot;)</code>. Note that <em>only</em> the <code>user</code> property will be observed; updating the <code>name</code> property on the user object alone doesn’t update the bound value — this can be solved by emitting a ‘Change’ event on the user object.</li>
<li>Bound property values can be changed using formatting ‘filters’, e.g. <code>bind(&quot;value|.2f&quot;)</code> results in a number with 2 decimal places, and <code>bind(&quot;!showResults&quot;)</code> results in the boolean <em>opposite</em> of the <code>showResults</code> property value.</li>
<li>Bindings can be combined logically (similar to <code>&amp;&amp;</code> and <code>||</code> operators in JavaScript) using the <a href="/docs/ref/Binding#Binding:and"><code>.and</code></a> and <a href="/docs/ref/Binding#Binding:or"><code>.or</code></a> methods, e.g. <code>bind(&quot;!noResults&quot;).and(&quot;showResults&quot;)</code>.</li>
<li>The <a href="/docs/ref/bindf"><code>bindf</code></a> function (bind <em>formatted</em>, in reference to the <code>printf</code> function that exists in C and many other programming languages) returns a binding that results in a string, incorporating the current value(s) of one or more bindings. E.g. <code>bindf(&quot;Buy %i for $%.2f&quot;, &quot;qty&quot;, &quot;price&quot;)</code> binds to the <code>qty</code> and <code>price</code> properties, but applies its result as a string such as “Buy 2 for $2.50”.</li>
</ul>
<h3>Event handlers</h3>


<p>If the first argument to <code>with</code> is a plain object, then this object may also include <em>event handlers</em> for specific events. For example, to handle <code>Click</code> events, include an <code>onClick</code> property in the argument to <code>with</code>.</p>
<p>You <em>may</em> include a handler function directly in the preset argument:</p>
<pre><code class="language-typescript"><span class="hljs-comment">// not best practice!</span>
<span class="hljs-keyword">const</span> view = UIRow.with(
  UIButton.with({
    <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Click me&quot;</span>,
    <span class="hljs-attr">onClick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
      <span class="hljs-comment">// ... user clicked the button</span>
      <span class="hljs-built_in">console</span>.log(e.name)  <span class="hljs-comment">// =&gt; &quot;Click&quot;</span>
    }
  })
)
</code></pre>
<p>However, in practice this not only makes (view) code more difficult to read, but also makes it more likely that business logic finds its way into other parts of the program — something that should generally be avoided.</p>
<p>Instead, the <code>onClick</code> property may be set to a string in one of the following formats:</p>
<ul>
<li><code>onClick: &quot;+Foo&quot;</code> instructs the (nested) component to listen for <code>Click</code> events, and emit a <code>Foo</code> event in response. The emitted event is an instance of <a href="/docs/ref/ComponentEvent"><code>ComponentEvent</code></a>, which refers to both the emitting component, and the original event.</li>
<li><code>onClick: &quot;foo()&quot;</code> instructs the component to listen for <code>Click</code> events, and <em>delegate</em> the event to the <code>foo()</code> method on the bound parent component, i.e. the same component that bound property values are taken from, usually the activity.</li>
</ul>
<p>Combining event handlers and bindings, the resulting ‘preset’ view component declaration describes an interactive user interface, without ever needing to create or update any of the view components directly.</p>
<p>The preset view constructor can then be passed to a preset activity constructor, to make sure that the resulting activity displays this view when it is active:</p>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> view = UIRow.with(
  UIButton.with({
    <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Click me&quot;</span>,
    <span class="hljs-attr">onClick</span>: <span class="hljs-string">&quot;addCount()&quot;</span>
  }),
  UILabel.withText(
    bindf(<span class="hljs-string">&quot;You clicked %i times&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>)
  )
)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PageViewActivity</span>.<span class="hljs-title">with</span>(<span class="hljs-title">view</span>) </span>{
  path = <span class="hljs-string">&quot;/&quot;</span>;
  count = <span class="hljs-number">0</span>;
  <span class="hljs-function"><span class="hljs-title">addCount</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-built_in">this</span>.count++ }
}
</code></pre>
<h2 id="custom">Custom presets</h2>


<p>A component class may define a custom function to handle preset arguments (i.e. the arguments passed to the <code>with</code> method) — although this is often not necesary in your own code; most of the standard view classes implement their own handlers.</p>
<p>For example, the <code>style</code> property passed to UI components is <em>not</em> directly copied to the resulting component — since that would completely override existing styles. Instead, the given styles are combined with the existing styles of that component.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> styles = UIStyle.group({
  <span class="hljs-attr">red</span>: { <span class="hljs-attr">textStyle</span>: { <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span> } },
  <span class="hljs-attr">bold</span>: { <span class="hljs-attr">textStyle</span>: { <span class="hljs-attr">bold</span>: <span class="hljs-literal">true</span> } }
})

<span class="hljs-keyword">const</span> MyRedButton = UIButton.with({
  <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;Click me&quot;</span>,
  <span class="hljs-attr">style</span>: styles.red  <span class="hljs-comment">// red text</span>
})
<span class="hljs-keyword">const</span> MyBoldRedButton = MyRedButton.with({
  <span class="hljs-attr">style</span>: styles.bold  <span class="hljs-comment">// red and bold</span>
})
</code></pre>
<h3>Overriding preset methods</h3>


<p>This behavior is implemented by the static <code>preset</code> method. This method is defined by the <code>Component</code> class, but it may be overridden.</p>
<blockquote>
<p><strong>Note:</strong> For custom views, it’s best to rely on the existing functionality of the <code>ViewComponent</code> class, rather than implementing your own <code>preset</code> method.</p>
</blockquote>
<p><a href="/docs/concepts/views" class="block_link doc"><strong>See also:</strong> Concepts &gt; Views</a></p>
<p>If you do need to implement custom preset behavior, override the static <code>preset</code> method. This method can intercept preset arguments before they are applied by the method defined by <code>Component</code>.</p>
<p>The <code>preset</code> method is called by <code>with</code> itself, right after creating the constructor that will eventually be returned. Here’s an example of a custom <code>preset</code> method:</p>
<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UIButton</span> </span>{
  <span class="hljs-comment">// override default behavior</span>
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">preset</span>(<span class="hljs-params">args: UIButton.Presets &amp; { fancy: <span class="hljs-built_in">boolean</span> }</span>)</span> {
    <span class="hljs-keyword">if</span> (args.fancy) {
      <span class="hljs-comment">// ...change presets here before they are applied,</span>
      <span class="hljs-comment">// if necessary</span>
    }

    <span class="hljs-comment">// this method returns a function that is run</span>
    <span class="hljs-comment">// for each instance by the new constructor:</span>
    <span class="hljs-keyword">let</span> f = <span class="hljs-built_in">super</span>.preset(args);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">this</span>: UIButton</span>) </span>{
      f.call(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// apply default behavior first</span>

      <span class="hljs-comment">// `this` refers to the button instance now</span>
      <span class="hljs-keyword">if</span> (args.fancy) {
        <span class="hljs-built_in">this</span>.label = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">this</span>.label).toUpperCase();
      }
    }
  }
}

<span class="hljs-keyword">let</span> B = MyButton.with({ <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-attr">fancy</span>: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">let</span> button = <span class="hljs-keyword">new</span> B();
<span class="hljs-built_in">console</span>.log(button.label);  <span class="hljs-comment">// =&gt; &quot;A&quot;</span>
</code></pre>
<p>Similarly, you can take any content (other arguments passed to <code>with</code>) as an array of constructors, and change or add to the array:</p>
<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UIRow</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">preset</span>(<span class="hljs-params">
    args: UICell.Presets,
    ...content: <span class="hljs-built_in">Array</span>&lt;UIRenderableConstructor | <span class="hljs-literal">undefined</span>&gt;</span>)</span> {
    content.reverse();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.preset(args, ...content);
  }
}
</code></pre>
<h3>Preset bindings and limiting bound properties</h3>


<p>The <code>preset</code> function can also be used to make the (new, preset) component class the ‘bound’ parent for any child components that may have been added. Note that this is <em>necessary</em>, because any bindings that were not included by/from the given class, will not work.</p>
<p>Bound properties can be limited to a specific set of properties — for example, this is how the <a href="/docs/ref/UIListCellAdapter"><code>UIListCellAdapter</code></a> class enables bindings to the <code>object</code>, <code>value</code>, <code>selected</code>, and <code>hovered</code> properties <em>of the list cell</em> while all other bindings still refer to the previously bound parent component, as illustrated below.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> view = UICell.with(
  UIListController.with(
    { <span class="hljs-attr">items</span>: bind(<span class="hljs-string">&quot;items&quot;</span>) },  <span class="hljs-comment">// a, b, c</span>
    
    <span class="hljs-comment">// this class *limits* bindings:</span>
    UIListCellAdapter.with(
      UIRow.with(
        <span class="hljs-comment">// this is bound to the activity:</span>
        UILabel.withText(bind(<span class="hljs-string">&quot;greeting&quot;</span>)),
        <span class="hljs-comment">// this is bound to the list item:</span>
        UILabel.withText(bindf(<span class="hljs-string">&quot;Item: %s&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>))
      )
    )
  )
)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PageViewActivity</span>.<span class="hljs-title">with</span>(<span class="hljs-title">view</span>) </span>{
  path = <span class="hljs-string">&quot;/&quot;</span>;
  greeting = <span class="hljs-string">&quot;Hello, world!&quot;</span>
  items = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]
}
</code></pre>
<p>The following methods should be used within the <code>preset</code> method if a component accepts further component declarations as arguments to <code>with</code> (similar to <code>UIListCellAdapter</code> above) which may include bindings to properties of the component <em>itself</em>.</p>
<p><a href="/docs/ref/Component#Component:presetBoundComponent" class="block_link method"><strong>Component.presetBoundComponent()</strong><br>Make this component the bound parent component for given child component type(s)</a>
<a href="/docs/ref/Component#Component:BoundComposition:limitBindings" class="block_link method"><strong>BoundComposition.limitBindings()</strong><br>Remove all bindings that are to be bound to properties that are not included in a given list</a></p>
<p>In practice these advanced techniques are rarely ever needed: custom view components already automate this setup using the <code>with</code> method of the <code>ViewComponent</code> class (making it unnecessary to use the methods above), and custom component declarations outside of the view don’t normally accept any component declarations with nested bindings.</p>
<hr>
<h3>Next steps</h3>


<p>Now that you have an understanding of the <code>Component</code> class, it’s time to look at how components are grouped into collections for data modeling and display.</p>
<ul>
<li>Learn about <a href="/docs/concepts/lists-maps">Lists and maps</a>.</li>
</ul>

        </div>

        <div class="wrapper_column wrapper_column--sidebar">
            <div class="fixed_cell">
                <div class="fixed_cell_inner">
                    <nav id="toc" class="sidebar_nav">
                        <h4 class="closed">Overview</h4>
                              <ul>
                                  <li><a href="/docs/goals">Why Typescene?</a></li><link rel="prefetch" href="/docs/goals" as="fetch" />
<li><a href="/docs/introduction">Introduction</a></li><link rel="prefetch" href="/docs/introduction" as="fetch" />
<li><a href="/docs/installation">Installation</a></li><link rel="prefetch" href="/docs/installation" as="fetch" />
<li><a href="/docs/js-ts">JavaScript vs TypeScript</a></li><link rel="prefetch" href="/docs/js-ts" as="fetch" />
                              </ul>
                              
<h4 class="open">Concepts</h4>
                              <ul>
                                  <li aria-current="page"><b>Components</b></li><ul>
<li><a href="#references" class="toc">Component references</a></li>
<li><a href="#events" class="toc">Events</a></li>
<li><a href="#observers" class="toc">Observers</a></li>
<li><a href="#ids-state" class="toc">IDs and state</a></li>
<li><a href="#preset" class="toc">Declarations</a></li>
<li><a href="#custom" class="toc">Custom presets</a></li>
</ul>

<li><a href="/docs/concepts/lists-maps">Lists and maps</a></li><link rel="prefetch" href="/docs/concepts/lists-maps" as="fetch" />
<li><a href="/docs/concepts/views">Views</a></li><link rel="prefetch" href="/docs/concepts/views" as="fetch" />
<li><a href="/docs/concepts/activities">Activities</a></li><link rel="prefetch" href="/docs/concepts/activities" as="fetch" />
<li><a href="/docs/concepts/services">Services</a></li><link rel="prefetch" href="/docs/concepts/services" as="fetch" />
                              </ul>
                              
<h4 class="closed">Guides</h4>
                              <ul>
                                  <li><a href="/docs/guides/ui/">UI components</a></li><link rel="prefetch" href="/docs/guides/ui/" as="fetch" />
<li><a href="/docs/guides/layout/">Layout</a></li><link rel="prefetch" href="/docs/guides/layout/" as="fetch" />
                              </ul>
                              
                    </nav>
                </div>
                <div class="fixed_cell_backtotop">
                    <a href="#" onclick="backToTop()">↑ Back to top</a>
                </div>
            </div>
        </div>
    </div>
</article>
<link rel="prefetch" href="/docs/" as="fetch" />

    <footer class="footer">
        <section class="wrapper">
            <div class="wrapper_columns">
                <div class="wrapper_column">
                    © Copyright 2021 Typescene contributors
                </div>
                <div class="wrapper_column wrapper_column--oppose style--light">
                    Find Typescene on
    <a href="https://twitter.com/typescene" target="_blank" rel="noopener">Twitter</a> and
    <a href="https://github.com/typescene" target="_blank" rel="noopener">Github</a>
                </div>
            </div>
        </section>
    </footer>

    <script src="/assets/default.js"></script>
    <script src="/assets/docwidget.js"></script>
</body>
</html>
